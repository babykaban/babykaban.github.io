<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="kL2NjtvChhJi-npbtl_4yNZj2UKrGmStbdgOgqRS8lU"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Advancing Navigation Meshes and Triangulation | BabyKaban </title> <meta name="author" content="Paul I. Solodrai"> <meta name="description" content="Editor update"> <meta name="keywords" content="blog, spellweaver saga, spellweaver, solodrai, babykaban, game engine"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/site_logo.jpeg?012e7a2c5e17fa21c2b2e608cf0cdb38"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://babykaban.github.io/blog/2024/editor-update-triangulation/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> BabyKaban </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">GitHub Repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Advancing Navigation Meshes and Triangulation</h1> <p class="post-meta"> Created in September 02, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/category/blog"> <i class="fa-solid fa-tag fa-sm"></i> blog</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="introduction">Introduction</h2> <p>Over the past few weeks, I’ve been focused on continuing my work with navigation meshes. After implementing features in the editor to create polygons, the next major step was triangulating those polygons. This is important to placing obstacles and later merging them into convex polygons. I will be using my previous algorithm to make holes in the triangulated polygons, representing obstacles. You can check out the details of that process in my <a href="https://babykaban.github.io/blog/2024/editor-update-triangle-subtraction/">previous post</a>.</p> <h2 id="diving-into-triangulation">Diving into Triangulation</h2> <p>After wrapping up triangle subtraction, I shifted my focus to implementing triangulation. The first approach I tried was Ear Clipping triangulation, a simple method that works well for basic polygons. I followed an implementation walkthrough from <a href="https://www.youtube.com/watch?v=hTJFcHutls8&amp;t=1648s" rel="external nofollow noopener" target="_blank">this video</a>. However, the Ear Clipping method described in this video is only effective for simple polygons, meaning no holes or intersecting edges.</p> <p>Despite its simplicity, there’s one significant caveat I encountered: the algorithm occasionally produces sliver triangles. While these aren’t always a major issue, they can result in small, almost negligible polygons during the subtraction process, which might pose problems later down the road.</p> <h2 id="exploring-delaunay-triangulation">Exploring Delaunay Triangulation</h2> <p>As I continued, I needed a more robust solution for triangulation, so I shifted my focus to Delaunay Triangulation. Initially, I struggled to find a ready-to-use implementation that I could port into my editor. Fortunately, I came across an excellent YouTube channel, <a href="https://www.youtube.com/@xmdi0" rel="external nofollow noopener" target="_blank">xmdi</a>, where the creator is building a CAD program from scratch in C. He had a few episodes dedicated to Delaunay Triangulation and even provided open-source code on GitHub.</p> <p><a href="https://en.wikipedia.org/wiki/Delaunay_triangulation" rel="external nofollow noopener" target="_blank">Delaunay Triangulation</a> is a method of dividing a set of points into triangles in such a way that no point is inside the circumcircle of any triangle. This creates triangles that are as equilateral as possible, avoiding sharp angles. It’s widely used in computer graphics and geographic information systems because it guarantees a well-behaved mesh and supports interpolation between points in an efficient way.</p> <p>The implementation xmdi follows is based on <a href="https://www.newcastle.edu.au/__data/assets/pdf_file/0017/22508/13_A-fast-algorithm-for-constructing-Delaunay-triangulations-in-the-plane.pdf" rel="external nofollow noopener" target="_blank">S.W.Sloan’s paper</a>, which in detail explains the algorithm. After porting the algorithm into my editor, I started stepping through it in the debugger to understand its inner workings. Watching the creator’s explanations and reviewing S.W.Sloan’s paper helped me to understand the details and mechanics behind this more complex triangulation method.</p> <h2 id="the-shift-to-constrained-delaunay-triangulation">The Shift to Constrained Delaunay Triangulation</h2> <p>After getting familiar with the Delaunay Triangulation algorithm, I tested it on my polygons. That’s when I ran into a new issue — this implementation didn’t handle polygon boundaries as I needed, working only for convex polygons. This limitation made it clear that I needed to switch to Constrained Delaunay Triangulation.</p> <p>In <a href="https://en.wikipedia.org/wiki/Constrained_Delaunay_triangulation" rel="external nofollow noopener" target="_blank">Constrained Delaunay Triangulation (CDT)</a>, additional constraints are introduced: the edges of the polygon (or any other constraints like holes) must be respected by the triangulation. This means that the triangles must not cross these edges, allowing it to handle complex shapes like non-convex polygons and polygons with holes, which is exactly what I needed for my navigation mesh.</p> <p>Luckily, xmdi had another video covering this exact topic, once again based on another <a href="https://www.newcastle.edu.au/__data/assets/pdf_file/0019/22519/23_A-fast-algortithm-for-generating-constrained-Delaunay-triangulations.pdf" rel="external nofollow noopener" target="_blank">S.W.Sloan’s paper</a>. I followed the same process as before, porting his implementation into my editor and digging into the algorithm. However, I found that an additional step was necessary — removing triangles that fall outside of the polygon.</p> <h2 id="splitting-concave-polygons-into-convex-parts">Splitting Concave Polygons into Convex Parts</h2> <p>I considered two options: creating an algorithm to remove these triangles or splitting non-convex polygons into convex parts. For some reason, I decided to pursue the second option.</p> <h3 id="how-the-algorithm-works">How the Algorithm Works</h3> <p>The algorithm first identifies reflex points, which are vertices that form angles greater than 180 degrees with their adjacent edges. For each reflex point, it calculates a perpendicular line facing inside the polygon, which is used to find an edge where this line intersects. The intersection point is then inserted into the polygon’s vertex array, splitting the polygon into smaller pieces.</p> <p>Here is a simplified breakdown of the algorithm:</p> <ul> <li> <strong>Finding Reflex Points</strong>: The algorithm loops through each vertex of the polygon and calculates the cross product of the vectors formed by adjacent vertices. If the cross product is positive, the vertex is a reflex point and we increment the count. Also the perpendicular line from reflex point is computed for futher computations.</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">v2</span> <span class="n">a</span> <span class="o">=</span> <span class="n">VertexCur</span> <span class="o">-</span> <span class="n">VertexPrev</span><span class="p">;</span>
    <span class="n">v2</span> <span class="n">b</span> <span class="o">=</span> <span class="n">VertexNext</span> <span class="o">-</span> <span class="n">VertexCur</span><span class="p">;</span>
        
    <span class="k">if</span><span class="p">(</span><span class="n">Cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2</span> <span class="n">Perpendicular</span> <span class="o">=</span> <span class="n">Perp</span><span class="p">(</span><span class="n">VertexPrev</span> <span class="o">-</span> <span class="n">VertexCur</span><span class="p">);</span>
        <span class="n">v2</span> <span class="n">NewP</span> <span class="o">=</span> <span class="n">VertexCur</span> <span class="o">+</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">Perpendicular</span><span class="p">)</span><span class="o">*</span><span class="mf">100.0</span><span class="n">f</span><span class="p">;</span>

        <span class="n">line</span> <span class="o">*</span><span class="n">Line</span> <span class="o">=</span> <span class="n">PerpLines</span> <span class="o">+</span> <span class="n">ReflexCount</span><span class="p">;</span>
        <span class="n">Line</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">VertexCur</span><span class="p">;</span>
        <span class="n">Line</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">NewP</span><span class="p">;</span>
        <span class="o">++</span><span class="n">ReflexCount</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <ul> <li> <strong>Finding Intersection</strong>: Then we loop through reflex points and look for the polygon edge that is intersecting with respective perpendicular and insert intersection point into the polygon’s vertex array. We also check if the intersection point is not equal to edge ends, because we won’t need to insert the point in this case.</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">ReflexIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ReflexIndex</span> <span class="o">&lt;</span> <span class="n">ReflexCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">ReflexIndex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">line</span> <span class="o">*</span><span class="n">ReflexPerp</span> <span class="o">=</span> <span class="n">PerpLines</span> <span class="o">+</span> <span class="n">ReflexIndex</span><span class="p">;</span>
        <span class="n">v2</span> <span class="n">p</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">VertexIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">VertexIndex</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
            <span class="o">++</span><span class="n">VertexIndex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">v2</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">VertexIndex</span><span class="p">];</span>
            <span class="n">v2</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[(</span><span class="n">VertexIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">LineIntersect</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">TRISUBInsertPointBetween</span><span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">{</span><span class="n">VertexIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">VertexIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)});</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <ul> <li> <strong>Constructing New Polygon</strong>: After inserting an intersection point (or not) we looking for reflex point index in polygon’s vertex array, it is needed to determine from where to start new polygon construction.</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">s32</span> <span class="n">Reflex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="n">Reflex</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <p>Afterward we calculating the step to determine which way would be the fastest to reach inserted point.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">s32</span> <span class="n">Backward</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reflex</span> <span class="o">-</span> <span class="n">VertexIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">)</span> <span class="o">%</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">VertexIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Reflex</span> <span class="o">+</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">)</span> <span class="o">%</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Forward</span> <span class="o">&gt;</span> <span class="n">Backward</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>                    
</code></pre></div></div> <p>Then we construct the new polygon by stepping through polygon vertices and recording them into new polygon vertex array.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// NOTE(babykaban): Construct resulting polygon</span>
    <span class="n">v2</span> <span class="n">TestP</span> <span class="o">=</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TestP</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">TestP</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">Reflex</span><span class="p">];</span>
        <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">TestP</span><span class="p">;</span>
        <span class="n">Reflex</span> <span class="o">=</span> <span class="n">GetIndex</span><span class="p">(</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">,</span> <span class="n">Reflex</span> <span class="o">+</span> <span class="n">Offset</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <ul> <li> <strong>Removing Vertices from Polygon</strong>: The next step is to basically cut of the vertices that we recorded in the new polygon excluding the ones that make the edge between the reflex point and intersection. Also we increment the result polygon count.</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// NOTE(babykaban): Remove vertices from TempPoly that are clipped by NewPoly </span>
    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2</span> <span class="n">Vertex</span> <span class="o">=</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">J</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                <span class="o">++</span><span class="n">J</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2</span> <span class="n">TVertex</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">J</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">TVertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">RemoveAt</span><span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">J</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="p">(</span><span class="o">*</span><span class="n">ResultCount</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div> <ul> <li> <strong>Incrementing the ReflexIndex</strong>: Then we need to corectly increment <code class="language-plaintext highlighter-rouge">ReflexIndex</code>. So we loop through new polygon vertices and testing if they are equal to any reflex points if so that means that they are included into new polygon and have to be skipped.</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">s32</span> <span class="n">Increase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">ReflexIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2</span> <span class="n">Vertex</span> <span class="o">=</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">PerpLines</span><span class="p">[</span><span class="n">Next</span><span class="p">].</span><span class="n">a</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">Next</span><span class="p">;</span>
            <span class="o">++</span><span class="n">Increase</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ReflexIndex</span> <span class="o">+=</span> <span class="n">Increase</span><span class="p">;</span>
</code></pre></div></div> <p>After that the process repeats until we gone through all reflex points.</p> <ul> <li> <strong>Convexcity Check</strong>: After the loop we have the set of polygons but they are not necessaraly convex, so we test each of them for convexcity and record their indecies into <code class="language-plaintext highlighter-rouge">NotConvexIndices</code> array.</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// NOTE(babykaban): Check if there are not-convex polygons present if so record the indices</span>
    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="n">ArrayEnd</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ResultCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">polygon2</span> <span class="o">*</span><span class="n">P</span> <span class="o">=</span> <span class="n">ResultArray</span> <span class="o">+</span> <span class="n">I</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">IsConvex</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">NotConvexIndices</span><span class="p">[(</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <ul> <li> <strong>Final Steps</strong>: If we found any not-convex polygons we need to repeat the process for each of the not-convex polygons for that I made a simple function to do that. I tried to make it recursive but there were a big load on stack when spliting big polygons.</li> </ul> <p>Here is utility fucntion for spliting polygon into convex parts:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">SplitPolygonIntoConvexParts</span><span class="p">(</span><span class="n">polygon2</span> <span class="o">*</span><span class="n">Polygons</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">Count</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">s32</span> <span class="n">Start</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">Count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">SplitPolygon</span><span class="p">(</span><span class="n">Polygons</span><span class="p">,</span> <span class="n">Count</span><span class="p">,</span> <span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">Start</span><span class="p">,</span> <span class="n">Arena</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">s32</span> <span class="n">NotConvexIndex</span> <span class="o">=</span> <span class="n">NotConvexIndices</span><span class="p">[(</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">(</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
        <span class="n">SplitPolygon</span><span class="p">(</span><span class="n">Polygons</span><span class="p">,</span> <span class="n">Count</span><span class="p">,</span> <span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">NotConvexIndex</span><span class="p">,</span> <span class="n">Arena</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>For those interested in implementation here is the full code:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">line</span>
<span class="p">{</span>
    <span class="n">v2</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">v2</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">RemoveAt</span><span class="p">(</span><span class="n">polygon2</span> <span class="o">*</span><span class="n">Poly</span><span class="p">,</span> <span class="n">s32</span> <span class="n">Index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="n">Index</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="o">--</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">internal</span> <span class="kt">void</span>
<span class="nf">SplitPolygon</span><span class="p">(</span><span class="n">polygon2</span> <span class="o">*</span><span class="n">ResultArray</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">ResultCount</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">s32</span> <span class="n">SubjectIndex</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">TempArena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">s32</span> <span class="n">ArrayEnd</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ResultCount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">polygon2</span> <span class="o">*</span><span class="n">Poly</span> <span class="o">=</span> <span class="n">ResultArray</span> <span class="o">+</span> <span class="n">SubjectIndex</span><span class="p">;</span>
    <span class="k">if</span><span class="p">((</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IsConvex</span><span class="p">(</span><span class="n">Poly</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">b32</span> <span class="n">Clockwise</span> <span class="o">=</span> <span class="p">(</span><span class="n">PolygonSignedArea</span><span class="p">(</span><span class="n">Poly</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
    
        <span class="n">s32</span> <span class="n">PrevOffset</span> <span class="o">=</span> <span class="n">Clockwise</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s32</span> <span class="n">NextOffset</span> <span class="o">=</span> <span class="n">Clockwise</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">s32</span> <span class="n">ReflexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">line</span> <span class="o">*</span><span class="n">PerpLines</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">TempArena</span><span class="p">,</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    
        <span class="c1">// TODO(babykaban): Cash calculated cross products</span>
        <span class="c1">// NOTE(babykaban): Found all reflex points and their perpendiculars</span>
        <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">VertexIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">VertexIndex</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
            <span class="o">++</span><span class="n">VertexIndex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">v2</span> <span class="n">VertexPrev</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">GetIndex</span><span class="p">(</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">,</span> <span class="n">VertexIndex</span> <span class="o">+</span> <span class="n">PrevOffset</span><span class="p">)];</span>
            <span class="n">v2</span> <span class="n">VertexCur</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">VertexIndex</span><span class="p">];</span>
            <span class="n">v2</span> <span class="n">VertexNext</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">GetIndex</span><span class="p">(</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">,</span> <span class="n">VertexIndex</span> <span class="o">+</span> <span class="n">NextOffset</span><span class="p">)];</span>
                
            <span class="n">v2</span> <span class="n">a</span> <span class="o">=</span> <span class="n">VertexCur</span> <span class="o">-</span> <span class="n">VertexPrev</span><span class="p">;</span>
            <span class="n">v2</span> <span class="n">b</span> <span class="o">=</span> <span class="n">VertexNext</span> <span class="o">-</span> <span class="n">VertexCur</span><span class="p">;</span>
                
            <span class="k">if</span><span class="p">(</span><span class="n">Cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2</span> <span class="n">Perpendicular</span> <span class="o">=</span> <span class="n">Perp</span><span class="p">(</span><span class="n">VertexPrev</span> <span class="o">-</span> <span class="n">VertexCur</span><span class="p">);</span>
                <span class="n">v2</span> <span class="n">NewP</span> <span class="o">=</span> <span class="n">VertexCur</span> <span class="o">+</span> <span class="n">Normalize</span><span class="p">(</span><span class="n">Perpendicular</span><span class="p">)</span><span class="o">*</span><span class="mf">100.0</span><span class="n">f</span><span class="p">;</span>

                <span class="n">line</span> <span class="o">*</span><span class="n">Line</span> <span class="o">=</span> <span class="n">PerpLines</span> <span class="o">+</span> <span class="n">ReflexCount</span><span class="p">;</span>
                <span class="n">Line</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">VertexCur</span><span class="p">;</span>
                <span class="n">Line</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="n">NewP</span><span class="p">;</span>
                <span class="o">++</span><span class="n">ReflexCount</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">polygon2</span> <span class="o">*</span><span class="n">NewPoly</span> <span class="o">=</span> <span class="n">ResultArray</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">ResultCount</span><span class="p">);</span>
        <span class="c1">// NOTE(babykaban): Loop through Reflex points and split polygon by its intersection with perpendicular</span>
        <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">ReflexIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">ReflexIndex</span> <span class="o">&lt;</span> <span class="n">ReflexCount</span><span class="p">;</span>
            <span class="o">++</span><span class="n">ReflexIndex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">line</span> <span class="o">*</span><span class="n">ReflexPerp</span> <span class="o">=</span> <span class="n">PerpLines</span> <span class="o">+</span> <span class="n">ReflexIndex</span><span class="p">;</span>
            <span class="n">v2</span> <span class="n">p</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">VertexIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">VertexIndex</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                <span class="o">++</span><span class="n">VertexIndex</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">VertexIndex</span><span class="p">];</span>
                <span class="n">v2</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[(</span><span class="n">VertexIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="n">LineIntersect</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">InsertPointBetween</span><span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="p">{</span><span class="n">VertexIndex</span><span class="p">,</span> <span class="p">(</span><span class="n">VertexIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)});</span>
                        <span class="p">}</span>

                        <span class="n">s32</span> <span class="n">Reflex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                            <span class="n">I</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                            <span class="o">++</span><span class="n">I</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="k">if</span><span class="p">(</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">]))</span>
                            <span class="p">{</span>
                                <span class="n">Reflex</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">s32</span> <span class="n">Backward</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reflex</span> <span class="o">-</span> <span class="n">VertexIndex</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">)</span> <span class="o">%</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                        <span class="n">s32</span> <span class="n">Forward</span> <span class="o">=</span> <span class="p">(</span><span class="n">VertexIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Reflex</span> <span class="o">+</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">)</span> <span class="o">%</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                        <span class="n">s32</span> <span class="n">Offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Forward</span> <span class="o">&gt;</span> <span class="n">Backward</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>                    
                        <span class="c1">// NOTE(babykaban): Construct resulting polygon</span>
                        <span class="n">v2</span> <span class="n">TestP</span> <span class="o">=</span> <span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
                        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TestP</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">TestP</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">Reflex</span><span class="p">];</span>
                            <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">TestP</span><span class="p">;</span>
                            <span class="n">Reflex</span> <span class="o">=</span> <span class="n">GetIndex</span><span class="p">(</span><span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">,</span> <span class="n">Reflex</span> <span class="o">+</span> <span class="n">Offset</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="c1">// NOTE(babykaban): Remove vertices from TempPoly that are clipped by NewPoly </span>
                        <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                            <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                            <span class="o">++</span><span class="n">I</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">v2</span> <span class="n">Vertex</span> <span class="o">=</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">];</span>
                            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">ReflexPerp</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">))</span>
                            <span class="p">{</span>
                                <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                                    <span class="n">J</span> <span class="o">&lt;</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                                    <span class="o">++</span><span class="n">J</span><span class="p">)</span>
                                <span class="p">{</span>
                                    <span class="n">v2</span> <span class="n">TVertex</span> <span class="o">=</span> <span class="n">Poly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">J</span><span class="p">];</span>
                                    <span class="k">if</span><span class="p">(</span><span class="n">SPLITPointsAreEqual</span><span class="p">(</span><span class="n">TVertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">))</span>
                                    <span class="p">{</span>
                                        <span class="n">RemoveAt</span><span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">J</span><span class="p">);</span>
                                        <span class="k">break</span><span class="p">;</span>
                                    <span class="p">}</span>
                                <span class="p">}</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                        
                        <span class="p">(</span><span class="o">*</span><span class="n">ResultCount</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

                        <span class="n">s32</span> <span class="n">Increase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="n">s32</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">ReflexIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                        <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                            <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
                            <span class="o">++</span><span class="n">I</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">v2</span> <span class="n">Vertex</span> <span class="o">=</span> <span class="n">NewPoly</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">];</span>
                            <span class="k">if</span><span class="p">(</span><span class="n">PointsAreEqual</span><span class="p">(</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">PerpLines</span><span class="p">[</span><span class="n">Next</span><span class="p">].</span><span class="n">a</span><span class="p">))</span>
                            <span class="p">{</span>
                                <span class="o">++</span><span class="n">Next</span><span class="p">;</span>
                                <span class="o">++</span><span class="n">Increase</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>

                        <span class="n">ReflexIndex</span> <span class="o">+=</span> <span class="n">Increase</span><span class="p">;</span>
                            
                        <span class="n">NewPoly</span> <span class="o">=</span> <span class="n">ResultArray</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">ResultCount</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// NOTE(babykaban): Check if there are not-convex polygons present if so record the indices</span>
    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="n">ArrayEnd</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">ResultCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">polygon2</span> <span class="o">*</span><span class="n">P</span> <span class="o">=</span> <span class="n">ResultArray</span> <span class="o">+</span> <span class="n">I</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">IsConvex</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">NotConvexIndices</span><span class="p">[(</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">SplitPolygonIntoConvexParts</span><span class="p">(</span><span class="n">polygon2</span> <span class="o">*</span><span class="n">Polygons</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">Count</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">s32</span> <span class="n">Start</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">Count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">SplitPolygon</span><span class="p">(</span><span class="n">Polygons</span><span class="p">,</span> <span class="n">Count</span><span class="p">,</span> <span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">Start</span><span class="p">,</span> <span class="n">Arena</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">s32</span> <span class="n">NotConvexIndex</span> <span class="o">=</span> <span class="n">NotConvexIndices</span><span class="p">[(</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">(</span><span class="o">*</span><span class="n">NotConvexCount</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
        <span class="n">SplitPolygon</span><span class="p">(</span><span class="n">Polygons</span><span class="p">,</span> <span class="n">Count</span><span class="p">,</span> <span class="n">NotConvexIndices</span><span class="p">,</span> <span class="n">NotConvexCount</span><span class="p">,</span> <span class="n">NotConvexIndex</span><span class="p">,</span> <span class="n">Arena</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="moving-forward">Moving Forward</h2> <p>While splitting concave polygons into convex parts was a useful solution to the problem, I still believe that developing an algorithm to remove triangles that fall outside the polygon would be a more efficient approach. Implementing such an algorithm could streamline the entire triangulation process by avoiding unnecessary polygon splitting altogether.</p> <p>As a next step, I plan to focus on creating this more efficient solution. The goal is to directly eliminate any triangles outside the polygon after performing Constrained Delaunay Triangulation.</p> <p>Take care, <strong><a href="https://github.com/babykaban" rel="external nofollow noopener" target="_blank">BabyKaban</a></strong></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/editor-update-triangle-subtraction/">Triangle Boolean Subtraction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/editor-update-map-mode/">Expanding the World Map Editor Mode</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/editor-update-sswm-format/">Introducing Spellweaver Saga World Map (SSWM)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/welcome-to-the-spellweaver-saga-blog/">Welcome to the Spellweaver Saga Blog!</a> </li> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2024 Paul I. Solodrai. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: September 03, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-89DCRVDVVQ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-89DCRVDVVQ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"This is a collaction of projects that I&#39;ve been working on or worked on.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-github-repositories",title:"GitHub Repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"post-advancing-navigation-meshes-and-triangulation",title:"Advancing Navigation Meshes and Triangulation",description:"Editor update",section:"Posts",handler:()=>{window.location.href="/blog/2024/editor-update-triangulation/"}},{id:"post-triangle-boolean-subtraction",title:"Triangle Boolean Subtraction",description:"Editor update",section:"Posts",handler:()=>{window.location.href="/blog/2024/editor-update-triangle-subtraction/"}},{id:"post-expanding-the-world-map-editor-mode",title:"Expanding the World Map Editor Mode",description:"Editor update",section:"Posts",handler:()=>{window.location.href="/blog/2024/editor-update-map-mode/"}},{id:"post-introducing-spellweaver-saga-world-map-sswm",title:"Introducing Spellweaver Saga World Map (SSWM)",description:"Editor update",section:"Posts",handler:()=>{window.location.href="/blog/2024/editor-update-sswm-format/"}},{id:"post-welcome-to-the-spellweaver-saga-blog",title:"Welcome to the Spellweaver Saga Blog!",description:"Very First Blog Post",section:"Posts",handler:()=>{window.location.href="/blog/2024/welcome-to-the-spellweaver-saga-blog/"}},{id:"news-very-first-blog-post-is-now-up-blog-2024-welcome-to-the-spellweaver-saga-blog",title:"[Very first blog post is now up!!!](/blog/2024/welcome-to-the-spellweaver-saga-blog/)",description:"",section:"News"},{id:"projects-spellweaver-saga-retrieving-the-legendary-relic",title:"Spellweaver Saga Retrieving The Legendary Relic",description:"This is the first video game that babykaban has been working on.",section:"Projects",handler:()=>{window.location.href="/projects/spellweaver_saga/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%70%61%75%6C%39%32%32%31%39@%70%72%6F%74%6F%6E.%6D%65","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/babykaban","_blank")}},{id:"socials-x",title:"X",description:"Twitter",section:"Socials",handler:()=>{window.open("https://twitter.com/BabyKaban","_blank")}},{id:"socials-youtube",title:"YouTube",section:"Socials",handler:()=>{window.open("https://youtube.com/@BabyKaban","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>