<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://babykaban.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://babykaban.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-05T03:34:38+00:00</updated><id>https://babykaban.github.io/feed.xml</id><title type="html">BabyKaban</title><subtitle>Spellweaver Saga: Retrieving The Legendary Relic is an indie game developed by babykaban. Set in the Middle Ages, it features a world filled with magic and mysterious creatures. In this game, you play as a young mage who learns to utilize elemental magic to complete quests, solve puzzles, and fight creatures in the quest to find the mysterious artifact his mentor was searching for. The game also offers rich world exploration, allowing you to uncover hidden secrets, and immerse yourself in a captivating medieval fantasy environment. </subtitle><entry><title type="html">Expanding the World Map Editor Mode</title><link href="https://babykaban.github.io/blog/2024/editor-update/" rel="alternate" type="text/html" title="Expanding the World Map Editor Mode"/><published>2024-08-04T00:00:00+00:00</published><updated>2024-08-04T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/editor-update</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/editor-update/"><![CDATA[<p>Hello, Spellweavers!</p> <p>I’m back with another update on the development of <strong>Spellweaver Saga: Retrieving The Legendary Relic</strong>. Over the past week, I’ve been focusing on enhancing the editor, particularly in creating and managing world maps. Let’s dive into new features that have been added!</p> <h2 id="creating-and-loading-world-maps">Creating and Loading World Maps</h2> <p>One of the advancements is the ability to create and load world maps directly within the editor. Now, you can easily start a new map or load an existing one, making the process of building your game world more efficient. Once you’ve selected the map you’ll be working on, you can choose tilesets loaded with the asset file, giving you full control over the terrain and environment.</p> <h2 id="enhanced-tile-selection-with-scrollable-window">Enhanced Tile Selection with Scrollable Window</h2> <p>To make tile placement more intuitive, I’ve introduced a scrollable tile selection window that appears at the top of the screen. You can now easily browse through your tilesets by scrolling the mouse wheel, making it quicker to find the right tile for the job.</p> <h2 id="introducing-tile-layers-for-better-sorting">Introducing Tile Layers for Better Sorting</h2> <p>To improve the visual organization and layering of tiles, I’ve implemented tile layers with different Z coordinates. Think of it as a z-buffer for tiles—this addition enhances the sorting of tiles, ensuring that everything displays correctly in the game environment.</p> <h2 id="auto-saving-and-map-bounds-checking">Auto-Saving and Map Bounds Checking</h2> <p>Building a robust and user-friendly editor means thinking ahead about potential issues. To prevent any mishaps, I’ve added an auto-save feature and additional checks for map bounds. This ensures that your progress is saved regularly, and any work outside the map’s limits is caught early.</p> <h2 id="tile-flood-fill-functionality">Tile Flood Fill Functionality</h2> <p>One of the most exciting features is the tile flood fill function, which allows you to fill large areas with a specific tile easily. Here’s a peek into the code that makes it all happen:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="kt">void</span>
<span class="nf">TileFloodFill</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">UndoStack</span><span class="p">,</span> <span class="n">world</span> <span class="o">*</span><span class="n">World</span><span class="p">,</span> <span class="n">world_position</span> <span class="n">StartP</span><span class="p">,</span> <span class="n">ssa_tile</span> <span class="n">NewTile</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ZLayer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sswm_ground_tile</span> <span class="o">*</span><span class="n">TargetGroundTiles</span> <span class="o">=</span> <span class="n">GetWorldMapGroundTile</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">StartP</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">TargetGroundTiles</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">u32</span> <span class="n">TargetChecksum</span> <span class="o">=</span> <span class="n">TargetGroundTiles</span><span class="o">-&gt;</span><span class="n">CheckSum</span><span class="p">[</span><span class="n">ZLayer</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">TargetChecksum</span> <span class="o">!=</span> <span class="n">NewTile</span><span class="p">.</span><span class="n">CheckSum</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">editor_action</span> <span class="n">FloodFillAction</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">Action_FloodFill</span><span class="p">;</span>
            <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">TileCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">PrevTiles</span> <span class="o">=</span> <span class="p">(</span><span class="n">sswm_ground_tile</span> <span class="o">*</span><span class="p">)</span><span class="n">Platform</span><span class="p">.</span><span class="n">AllocateMemory</span><span class="p">(</span><span class="n">MAX_FILL_TILES</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">sswm_ground_tile</span><span class="p">));</span>

            <span class="n">tile_queue</span> <span class="n">Queue</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">Queue</span><span class="p">.</span><span class="n">Front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">Queue</span><span class="p">.</span><span class="n">Rear</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">StartP</span><span class="p">);</span>

            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">world_position</span> <span class="n">P</span> <span class="o">=</span> <span class="n">DeQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">);</span>

                <span class="n">sswm_ground_tile</span> <span class="o">*</span><span class="n">GroundTile</span> <span class="o">=</span> <span class="n">GetWorldMapGroundTile</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">GroundTile</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">GroundTile</span><span class="o">-&gt;</span><span class="n">CheckSum</span><span class="p">[</span><span class="n">ZLayer</span><span class="p">]</span> <span class="o">==</span> <span class="n">TargetChecksum</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">Copy</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sswm_ground_tile</span><span class="p">),</span> <span class="n">GroundTile</span><span class="p">,</span> <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">PrevTiles</span> <span class="o">+</span> <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">TileCount</span><span class="o">++</span><span class="p">);</span>

                        <span class="n">AddGroundTile</span><span class="p">(</span><span class="n">UndoStack</span><span class="p">,</span> <span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">NewTile</span><span class="p">,</span> <span class="n">ZLayer</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                        
                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">));</span>
                        <span class="p">}</span>

                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">));</span>
                        <span class="p">}</span>

                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                        <span class="p">}</span>

                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">PushOnActionStack</span><span class="p">(</span><span class="n">UndoStack</span><span class="p">,</span> <span class="n">FloodFillAction</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This function not only simplifies the tile placement process but also supports undo actions, allowing for greater flexibility and creativity while building your world.</p> <h2 id="implementing-undo-and-redo-functionality">Implementing Undo and Redo Functionality</h2> <p>After spending some time working with these new tools, I realized how crucial it was to have the ability to undo and redo actions. To address this, I introduced an <code class="language-plaintext highlighter-rouge">action_stack</code> system that can store and manage actions, allowing you to revert or reapply them as needed. Here’s a look at how this system works:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_UNDO_ACTIONS 128
</span><span class="k">struct</span> <span class="nc">action_stack</span>
<span class="p">{</span>
    <span class="n">editor_action</span> <span class="o">*</span><span class="n">Actions</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Start</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">End</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">Size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>This <code class="language-plaintext highlighter-rouge">action_stack</code> structure holds an array of <code class="language-plaintext highlighter-rouge">editor_action</code> objects, as well as pointers to the start and end of the stack, and a size indicator. It can store up to 128 actions for undoing and redoing.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">editor_action</span>
<span class="p">{</span>
    <span class="n">action_type</span> <span class="n">Type</span><span class="p">;</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">sswm_ground_tile</span> <span class="n">PrevTile</span><span class="p">;</span>
        <span class="n">flood_fill_action</span> <span class="n">FloodFill</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">editor_action</code> structure includes the type of action and a union to hold the relevant data for undoing or redoing the action. This allows for flexibility in handling different types of actions, whether it’s a simple tile change or a complex flood fill.</p> <p>Here are a few utility functions that manage the stack:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">InitActionStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">Arena</span><span class="p">,</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">,</span> <span class="n">editor_action</span><span class="p">);</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">InitActionStack</code> initializes the stack, setting up the memory for storing actions and resetting the start, end, and size indicators.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="n">b32</span>
<span class="nf">IsActionStackEmpty</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b32</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">IsActionStackEmpty</code> checks if the stack is empty by evaluating the size.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="kt">void</span>
<span class="nf">PushOnActionStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">,</span> <span class="n">editor_action</span> <span class="n">Action</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span><span class="p">[</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">]</span> <span class="o">=</span> <span class="n">Action</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">&lt;</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">PushOnActionStack</code> adds a new action to the stack. If the stack is full, it overwrites the oldest action.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="n">editor_action</span> <span class="o">*</span>
<span class="nf">PopFromActionStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">editor_action</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">IsActionStackEmpty</span><span class="p">(</span><span class="n">Stack</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">;</span>
        <span class="o">--</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">;</span>

        <span class="n">Result</span> <span class="o">=</span> <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span> <span class="o">+</span> <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">PopFromActionStack</code> removes the most recent action from the stack, allowing it to be undone.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ClearStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ZeroArray</span><span class="p">(</span><span class="n">MAX_UNDO_ACTIONS</span><span class="p">,</span> <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span><span class="p">);</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Finally, <code class="language-plaintext highlighter-rouge">ClearStack</code> resets the entire stack, clearing all stored actions.</p> <h2 id="whats-next">What’s Next?</h2> <p>The journey doesn’t end here! I’m already working on implementing navigation meshes and will continue refining the editor to enhance usability and expand its capabilities. My goal is to make building the world of Spellweaver Saga as intuitive and enjoyable as possible. There is a little gelery below, you can check it out.</p> <p>Happy spellweaving, <strong><a href="https://github.com/babaykaban">BabyKaban</a></strong></p>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Editor update]]></summary></entry><entry><title type="html">Introducing Spellweaver Saga World Map (SSWM)</title><link href="https://babykaban.github.io/blog/2024/editor-update/" rel="alternate" type="text/html" title="Introducing Spellweaver Saga World Map (SSWM)"/><published>2024-07-29T00:00:00+00:00</published><updated>2024-07-29T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/editor-update</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/editor-update/"><![CDATA[<p>Hello, Spellweavers!</p> <p>I’m excited to share a significant update in the development of <strong>Spellweaver Saga: Retrieving The Legendary Relic</strong>. As I delve deeper into refining the game’s mechanics and world-building tools, I’ve decided to rebuild the editor’s ‘terrain’ mode and introduce a fresh file format called <strong>Spellweaver Saga World Map (SSWM)</strong>.</p> <h2 id="the-evolution-of-terrain-mode">The Evolution of Terrain Mode</h2> <p>In the previous iteration of the editor, the terrain mode was relatively straightforward. It was essentially a grid where I could place different tiles to create a tile map. While this was functional, it lacked the flexibility needed for the interactions I envisioned in the game.</p> <h2 id="sswm-a-new-file-format">SSWM: A New File Format</h2> <p>The SSWM file format represents a significant leap forward in how the game’s world is structured and managed. Here’s what SSWM brings to the table:</p> <ul> <li><strong>Tile Grid</strong>: This grid holds bitmap IDs for ground tiles along with their positions, almost like the previous version. This change allows tiles to be spawned as entities, opening up a world of interaction possibilities within the game.</li> <li><strong>Entities Metadata</strong>: An array of entities’ metadata will be stored within the SSWM file, facilitating more dynamic and rich world creation.</li> <li><strong>Polygons and Navigation Meshes</strong>: One of the most exciting additions is the potential to store polygons and graphs for navigation meshes. This idea appeared as I was refining the current movement system and realized that it sucked. Navigation meshes will enhance pathfinding and movement, making gameplay smoother and more intuitive.</li> </ul> <h2 id="why-sswm">Why SSWM?</h2> <p>The beauty of SSWM files lies in their versatility. They will be stored in the game asset file format, <strong>Spellweaver Saga Assets (SSA)</strong>, ensuring seamless integration and organization of all game assets.</p> <h2 id="whats-next">What’s Next?</h2> <p>Next, I’ll focus on improving and continuing to develop the editor to create game levels. This involves enhancing the tools to generate polygons and graphs for navigation meshes and refining other aspects to make level creation more efficient.</p> <p>Stay tuned for more updates as I continue to build and refine <strong>Spellweaver Saga: Retrieving The Legendary Relic</strong>. Your support and enthusiasm fuel this adventure!</p> <p>Happy spellweaving, Paul</p>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Editor update]]></summary></entry><entry><title type="html">Welcome to the Spellweaver Saga Blog!</title><link href="https://babykaban.github.io/blog/2024/welcome-to-the-spellweaver-saga-blog/" rel="alternate" type="text/html" title="Welcome to the Spellweaver Saga Blog!"/><published>2024-07-24T00:00:00+00:00</published><updated>2024-07-24T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/welcome-to-the-spellweaver-saga-blog</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/welcome-to-the-spellweaver-saga-blog/"><![CDATA[<p>Hello everyone,</p> <p>Welcome to the very first blog post for Spellweaver Saga: Retrieving The Legendary Relic! I’m Paul, the developer behind this indie game, and I’m excited to share my journey with you as I work on bringing this project to life.</p> <h1 id="game-concept">Game Concept</h1> <p>The main concept of Spellweaver Saga revolves around the player’s ability to manipulate magic elements and combine them into spells or perform actions. This mechanic is central to the entire gameplay experience. The story follows a young mage who embarks on a quest to find a powerful artifact to protect his village. This artifact was researched by his mentor, who mysteriously disappeared.</p> <h1 id="development-journey">Development Journey</h1> <p>This game is being developed on a custom engine written in C/C++. I chose to develop my own engine to deepen my understanding of programming. Although the engine is still a work in progress, I decided to proceed with creating a game to test its capabilities. After completing a prototype and evaluating the engine’s abilities, I began designing and developing the game. There were many challenges along the way, especially since I was new to game and engine development.</p> <h1 id="challenges-and-solutions">Challenges and Solutions</h1> <p>One of the most significant challenges was the overall development process. I was able to overcome many hurdles thanks to the guidance provided by the video series Handmade Hero by Casey Muratori and other internet sources. These resources have been invaluable in helping me understand game development on a deeper level.</p> <h1 id="prototype-features">Prototype Features</h1> <p>The current prototype includes a basic map layout, a few quests, and the core mechanic of combining elements. This mechanic will be significantly improved in the next version of the game. Over the last few months, I have also been working on the game’s editor, which is a crucial part of the development process. The editor currently has the capability to create custom asset files for the game.</p> <h1 id="next-steps">Next Steps</h1> <p>The next steps in the development process include finishing the editor and starting on the first levels and designs of the game. I am excited to continue this journey and share updates with you as the game progresses.</p> <h1 id="community-and-feedback">Community and Feedback</h1> <p>You can find the game prototype on the <a href="/projects/spellweaver_saga/">projects page</a> or watch a demo <a href="https://www.youtube.com/watch?v=7211-m05OSI">here</a>. I would love to hear your feedback and thoughts as I continue to develop Spellweaver Saga. Your input will be invaluable in shaping the final game.</p> <p>Thank you for joining me on this journey. Stay tuned for more updates and insights into the development process of Spellweaver Saga: Retrieving The Legendary Relic.</p> <p>Best, Paul</p>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Very First Blog Post]]></summary></entry></feed>