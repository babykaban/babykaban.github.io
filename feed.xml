<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://babykaban.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://babykaban.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-18T22:17:21+00:00</updated><id>https://babykaban.github.io/feed.xml</id><title type="html">BabyKaban</title><subtitle>Spellweaver Saga: Retrieving The Legendary Relic is an indie game developed by babykaban. Set in the Middle Ages, it features a world filled with magic and mysterious creatures. In this game, you play as a young mage who learns to utilize elemental magic to complete quests, solve puzzles, and fight creatures in the quest to find the mysterious artifact his mentor was searching for. The game also offers rich world exploration, allowing you to uncover hidden secrets, and immerse yourself in a captivating medieval fantasy environment. </subtitle><entry><title type="html">Triange Boolean Subtraction</title><link href="https://babykaban.github.io/blog/2024/editor-update-triangle-subtraction/" rel="alternate" type="text/html" title="Triange Boolean Subtraction"/><published>2024-08-18T00:00:00+00:00</published><updated>2024-08-18T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/editor-update-triangle-subtraction</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/editor-update-triangle-subtraction/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>The need to create holes in navigation mesh polygons, described as obstacles, led me to develop this algorithm. Initially, I researched existing algorithms that could perform this task, but I couldn’t find any ready-to-use solutions. However, I did find a detailed documentation that outlines how to construct such an algorithm, which you can check out <a href="https://www.pnnl.gov/main/publications/external/technical_reports/PNNL-SA-97135.pdf">here</a>.</p> <p>Using this as a foundation, I started building the algorithm. After some tests on various polygon types and the decision to use single precision floating point, the algorithm began to exhibit issues—sometimes crashing, other times producing incorrect results.</p> <p>To simplify the task, I opted to perform the subtraction on triangles, reducing the possible cases to 20. From here, I began developing the algorithm based on the documentation’s guidelines.</p> <p>For those who just want to see or use the code without reading through the whole explanation, here’s the <a href="https://github.com/babykaban/Triangle-Boolean-Subtraction-Algorithm">GitHub link</a>.</p> <h2 id="implementation">Implementation</h2> <p>The image below will appear throughout the implementation steps to illustrate how it changes.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/subtract_0-480.webp 480w,/assets/img/subtract_0-800.webp 800w,/assets/img/subtract_0-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/subtract_0.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Blue triangle is `Subject` and red is `Subtractor`. </div> <p>The first step is to check if two triangles overlap, excluding edges and vertices. For this, I used the <a href="https://dyn4j.org/2010/01/sat/">Separating Axis Theorem (SAT)</a>. Then, I corrected the triangles’ orientation. The documentation suggests calculating an offset based on the polygons’ orientation, but for simplicity, I made the algorithm work only on clockwise triangles. If necessary, the triangles are reoriented by swapping the second and last vertices.</p> <p>Next, I checked for triangle collinearity to eliminate cases with sliver triangles. If all checks pass, we create a polygon to hold points from the Subject triangle, allowing for the insertion of additional points if needed. The overlap polygon is then calculated using the <a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland-Hodgman algorithm for clipping</a>.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/subtract_1-480.webp 480w,/assets/img/subtract_1-800.webp 800w,/assets/img/subtract_1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/subtract_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Now the yellow polygon becomes the `Subtractor`. </div> <p>Once the <code class="language-plaintext highlighter-rouge">Subtractor</code> is created, it should be cleaned up by removing duplicate points and merging those that are very close together. We then check if the <code class="language-plaintext highlighter-rouge">Subtractor's</code> area is significant enough and if the difference between the <code class="language-plaintext highlighter-rouge">Subtractor's</code> area and the <code class="language-plaintext highlighter-rouge">Subject's</code> area is sufficient to proceed.</p> <p>We then check if any vertex of the <code class="language-plaintext highlighter-rouge">Subtractor</code> lies on the first vertex of the <code class="language-plaintext highlighter-rouge">Subject</code>. If so, the points of the Subject are rotated clockwise in the array to avoid stacking too many points in one place and ensure the algorithm functions correctly. The first vertices of both the <code class="language-plaintext highlighter-rouge">Subject</code> and <code class="language-plaintext highlighter-rouge">Subtractor</code> are duplicated to their respective ends.</p> <p>Next, we identify all points of the <code class="language-plaintext highlighter-rouge">Subject</code> that lie outside the <code class="language-plaintext highlighter-rouge">Subtractor</code>. This is straightforward, as points not found in the <code class="language-plaintext highlighter-rouge">Subtractor</code> are considered outside. We then determine which points of the <code class="language-plaintext highlighter-rouge">Subtractor</code> are on the <code class="language-plaintext highlighter-rouge">Subject's</code> edges and which edges they belong to. The result is a sorted array of points and a table detailing how many points are on each <code class="language-plaintext highlighter-rouge">Subject</code> edge. If no intersection points are found, we record the <code class="language-plaintext highlighter-rouge">Subtractor</code> as a hole in the <code class="language-plaintext highlighter-rouge">Subject</code> and exit the function.</p> <p>Here are two function that perform operation above</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="n">points_between</span> <span class="o">*</span>
<span class="nf">GetIntersectionPointsF32</span><span class="p">(</span><span class="n">polygon2</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">polygon2</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="n">v2</span> <span class="o">*</span><span class="n">OutputPoints</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">OutputCount</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">points_between</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">Arena</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">points_between</span><span class="p">);</span>

    <span class="n">temporary_memory</span> <span class="n">TempMem</span> <span class="o">=</span> <span class="n">BeginTemporaryMemory</span><span class="p">(</span><span class="n">Arena</span><span class="p">);</span>
    <span class="n">s32</span> <span class="n">TempCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v2</span> <span class="o">*</span><span class="n">Temp</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">TempMem</span><span class="p">.</span><span class="n">Arena</span><span class="p">,</span> <span class="n">SUBTRACTION_MAX_POINTS_PER_POLYGON</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">v2</span> <span class="n">Prv</span> <span class="o">=</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">];</span>
        <span class="n">v2</span> <span class="n">Cur</span> <span class="o">=</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[(</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">PointsAreEqualF32</span><span class="p">(</span><span class="n">Prv</span><span class="p">,</span> <span class="n">Cur</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">IntersectLineSegmentF32</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Prv</span><span class="p">,</span> <span class="n">Cur</span><span class="p">,</span> <span class="n">Temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">TempCount</span><span class="p">,</span> <span class="n">Arena</span><span class="p">);</span>
            <span class="n">s32</span> <span class="n">AddedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">J</span> <span class="o">&lt;</span> <span class="n">TempCount</span><span class="p">;</span>
                <span class="o">++</span><span class="n">J</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">IsNewPointF32</span><span class="p">(</span><span class="n">OutputPoints</span><span class="p">,</span> <span class="o">*</span><span class="n">OutputCount</span><span class="p">,</span> <span class="n">Temp</span><span class="p">[</span><span class="n">J</span><span class="p">]))</span>
                <span class="p">{</span>
                    <span class="n">OutputPoints</span><span class="p">[(</span><span class="o">*</span><span class="n">OutputCount</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Temp</span><span class="p">[</span><span class="n">J</span><span class="p">];</span>
                    <span class="o">++</span><span class="n">AddedCount</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">Result</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">Count</span> <span class="o">=</span> <span class="n">AddedCount</span><span class="p">;</span>
            <span class="n">Result</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">I0</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
            <span class="n">Result</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">I1</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">VertexCount</span><span class="p">;</span>
            
            <span class="n">TempCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">EndTemporaryMemory</span><span class="p">(</span><span class="n">TempMem</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">internal</span> <span class="n">b32</span>
<span class="nf">IntersectLineSegmentF32</span><span class="p">(</span><span class="n">polygon2</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="n">v2</span> <span class="n">p1</span><span class="p">,</span> <span class="n">v2</span> <span class="n">p2</span><span class="p">,</span> <span class="n">v2</span> <span class="o">*</span><span class="n">Points</span><span class="p">,</span> <span class="n">s32</span> <span class="o">*</span><span class="n">PointCount</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">temporary_memory</span> <span class="n">TempMem</span> <span class="o">=</span> <span class="n">BeginTemporaryMemory</span><span class="p">(</span><span class="n">Arena</span><span class="p">);</span>

    <span class="n">b32</span> <span class="n">Intersect</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">TempPointCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v2</span> <span class="o">*</span><span class="n">TempPoints</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">TempMem</span><span class="p">.</span><span class="n">Arena</span><span class="p">,</span> <span class="n">SUBTRACTION_MAX_POINTS_PER_POLYGON</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">I</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">VertexCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">s32</span> <span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">VertexCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">v2</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">I</span><span class="p">];</span>
        <span class="n">v2</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">A</span><span class="o">-&gt;</span><span class="n">Vertices</span><span class="p">[</span><span class="n">J</span><span class="p">];</span>

        <span class="n">b32</span> <span class="n">Ends</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">DistanceToSegmentF32</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SUBTRACT_DISTANCE_TO_EPSILON_F32</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TempPoints</span><span class="p">[</span><span class="n">TempPointCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>
            <span class="n">Intersect</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">Ends</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">DistanceToSegmentF32</span><span class="p">(</span><span class="n">p4</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SUBTRACT_DISTANCE_TO_EPSILON_F32</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TempPoints</span><span class="p">[</span><span class="n">TempPointCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">p4</span><span class="p">;</span>
            <span class="n">Intersect</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">Ends</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">TempPointCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ZeroArray</span><span class="p">((</span><span class="o">*</span><span class="n">PointCount</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span> <span class="n">Points</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">TempPointCount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Points</span><span class="p">[(</span><span class="o">*</span><span class="n">PointCount</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">TempPoints</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">s32</span> <span class="n">SortCount</span> <span class="o">=</span> <span class="n">TempPointCount</span><span class="p">;</span>
            <span class="n">sort_entry</span> <span class="o">*</span><span class="n">SortArray</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">TempMem</span><span class="p">.</span><span class="n">Arena</span><span class="p">,</span> <span class="n">TempPointCount</span><span class="p">,</span> <span class="n">sort_entry</span><span class="p">);</span>
            <span class="n">sort_entry</span> <span class="o">*</span><span class="n">Temp</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">TempMem</span><span class="p">.</span><span class="n">Arena</span><span class="p">,</span> <span class="n">TempPointCount</span><span class="p">,</span> <span class="n">sort_entry</span><span class="p">);</span>
            <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">I</span> <span class="o">&lt;</span> <span class="n">TempPointCount</span><span class="p">;</span>
                <span class="o">++</span><span class="n">I</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">sort_entry</span> <span class="o">*</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">SortArray</span> <span class="o">+</span> <span class="n">I</span><span class="p">;</span>
                <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">Index</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
                <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">SortKey</span> <span class="o">=</span> <span class="n">Length</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">TempPoints</span><span class="p">[</span><span class="n">I</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="n">RadixSort</span><span class="p">(</span><span class="n">SortCount</span><span class="p">,</span> <span class="n">SortArray</span><span class="p">,</span> <span class="n">Temp</span><span class="p">);</span>

            <span class="n">v2</span> <span class="n">Last</span> <span class="o">=</span> <span class="n">TempPoints</span><span class="p">[</span><span class="n">SortArray</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Index</span><span class="p">];</span>
            <span class="n">Points</span><span class="p">[(</span><span class="o">*</span><span class="n">PointCount</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">Last</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">s32</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">I</span> <span class="o">&lt;</span> <span class="n">TempPointCount</span><span class="p">;</span>
                <span class="o">++</span><span class="n">I</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2</span> <span class="n">This</span> <span class="o">=</span> <span class="n">TempPoints</span><span class="p">[</span><span class="n">SortArray</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">Index</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">PointsAreEqualF32</span><span class="p">(</span><span class="n">This</span><span class="p">,</span> <span class="n">Last</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">Points</span><span class="p">[(</span><span class="o">*</span><span class="n">PointCount</span><span class="p">)</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">This</span><span class="p">;</span>
                    <span class="n">Last</span> <span class="o">=</span> <span class="n">This</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">EndTemporaryMemory</span><span class="p">(</span><span class="n">TempMem</span><span class="p">);</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">Intersect</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>For the example illustrated above, the table will look like this: | Edge Start Index | Edge End Index | Point Count | | :————–: | :————: | :———: | | 0 | 1 | 0 | | 1 | 2 | 2 | | 2 | 3 | 2 |</p> <p>If points are found, they are inserted into the Subject in the places described by the resulting table. We then need to build more tables, one for the Subject and one for the Subtractor. These tables contain information about each vertex of each polygon—whether the point is outside, if it is a crossing point, which point it crosses, a processed flag, and the point itself.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/subtract_2-480.webp 480w,/assets/img/subtract_2-800.webp 800w,/assets/img/subtract_2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/subtract_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Updated image with inserted points and their coordinates. </div> <p>As a result, we have two tables that look like this:</p> <p><em>Subject Vertex Info</em> | Vertex Index | Point (x, y) | Outside Flag | Cross | Processed Flag | | :———-: | :———-: | :———-: | :—: | :————: | | 0 | (-8, 12) | true | -1 | false | | 1 | (8, 18) | true | -1 | false | | 2 | (10, 11) | false | 1 | false | | 3 | (11.1, 7.1) | false | 2 | false | | 4 | (16, -10) | true | -1 | false | | 5 | (4.5, 0.5) | false | 3 | false | | 6 | (-0.9, 5.5) | false | 4 | false | | 7 | (-8, 12) | true | -1 | false |</p> <p><em>Subtractor Vertex Info</em> | Vertex Index | Point (x, y) | Outside Flag | Cross | Processed Flag | | :———-: | :———-: | :———-: | :—: | :————: | | 0 | (-0.9, 5.5) | false | 6 | false | | 1 | (10, 11) | false | 2 | false | | 2 | (11.1, 7.1) | false | 3 | false | | 3 | (4.5, 0.5) | false | 5 | false | | 4 | (-0.9, 5.5) | false | 6 | false |</p> <p>With these tables built, the function that creates the resulting polygons is run, and the process is finished. The function that constructs the polygons is similar to the one described in the documentation, with a few modifications, so feel free to read through the implementation steps in section 2.5 <a href="https://www.pnnl.gov/main/publications/external/technical_reports/PNNL-SA-97135.pdf">here</a>.</p> <p>The result of this fucntion you can see below:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/subtract_3-480.webp 480w,/assets/img/subtract_3-800.webp 800w,/assets/img/subtract_3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/subtract_3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Resulting polygons A and B. </div> <h2 id="why-single-precision-floating-point">Why Single Precision Floating Point?</h2> <p>The initial implementation used double precision floating point, which has its advantages—fewer checks are needed, and results are more accurate for very small triangles. However, because this function will be used in a game, speed is crucial. Comparing the worst cases of both implementations, the single precision version is 1-1.5 times faster.</p> <p>In benchmarks, the double-precision implementation consumes around 250,000 CPU cycles per frame in debug mode, while the single-precision version uses about 100,000 cycles. Additionally, the double precision requires twice as much memory as the single precision.</p> <h2 id="what-is-the-caveat">What is the Caveat?</h2> <p>The expected issue with the single precision implementation was incorrect handling of cases where <code class="language-plaintext highlighter-rouge">Subtractor</code> vertices or edges are very close to <code class="language-plaintext highlighter-rouge">Subject</code> vertices or edges. I addressed this by using <code class="language-plaintext highlighter-rouge">EPSILON</code> and merging points that are very close together, though finding the correct <code class="language-plaintext highlighter-rouge">EPSILON</code> value took some time.</p> <h2 id="conclusion">Conclusion</h2> <p>The algorithm now works efficiently and quickly, though there’s always room for improvement. I tested the algorithm by generating overlapping triangles across all 20 cases, testing 2,048 cases per frame, which translates to about 7.4 billion cases per hour. After several hours of testing, no cases crashed, which I believe confirms the algorithm’s reliability.</p> <p>That’s it for this post. If you want to implement your own algorithm, the <a href="https://www.pnnl.gov/main/publications/external/technical_reports/PNNL-SA-97135.pdf">documentation</a> I used is quite helpful—much of the code comes directly from there. Otherwise, you can check out my <a href="https://github.com/babykaban/Triangle-Boolean-Subtraction-Algorithm">repo</a> with the source code of the implementation described.</p> <p>Take care, <strong><a href="https://github.com/babykaban">BabyKaban</a></strong></p>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Editor update]]></summary></entry><entry><title type="html">Expanding the World Map Editor Mode</title><link href="https://babykaban.github.io/blog/2024/editor-update-map-mode/" rel="alternate" type="text/html" title="Expanding the World Map Editor Mode"/><published>2024-08-04T00:00:00+00:00</published><updated>2024-08-04T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/editor-update-map-mode</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/editor-update-map-mode/"><![CDATA[<p>Hello, Spellweavers!</p> <p>I’m back with another update on the development of <strong>Spellweaver Saga: Retrieving The Legendary Relic</strong>. Over the past week, I’ve been focusing on enhancing the editor, particularly in creating and managing world maps. Let’s dive into new features that have been added!</p> <h2 id="creating-and-loading-world-maps">Creating and Loading World Maps</h2> <p>One of the advancements is the ability to create and load world maps directly within the editor. Now, you can easily start a new map or load an existing one, making the process of building your game world more efficient. Once you’ve selected the map you’ll be working on, you can choose tilesets loaded with the asset file, giving you full control over the terrain and environment.</p> <h2 id="enhanced-tile-selection-with-scrollable-window">Enhanced Tile Selection with Scrollable Window</h2> <p>To make tile placement more intuitive, I’ve introduced a scrollable tile selection window that appears at the top of the screen. You can now easily browse through your tilesets by scrolling the mouse wheel, making it quicker to find the right tile for the job.</p> <h2 id="introducing-tile-layers-for-better-sorting">Introducing Tile Layers for Better Sorting</h2> <p>To improve the visual organization and layering of tiles, I’ve implemented tile layers with different Z coordinates. Think of it as a z-buffer for tiles—this addition enhances the sorting of tiles, ensuring that everything displays correctly in the game environment.</p> <h2 id="auto-saving-and-map-bounds-checking">Auto-Saving and Map Bounds Checking</h2> <p>Building a robust and user-friendly editor means thinking ahead about potential issues. To prevent any mishaps, I’ve added an auto-save feature and additional checks for map bounds. This ensures that your progress is saved regularly, and any work outside the map’s limits is caught early.</p> <h2 id="tile-flood-fill-functionality">Tile Flood Fill Functionality</h2> <p>One of the most exciting features is the tile flood fill function, which allows you to fill large areas with a specific tile easily. Here’s a peek into the code that makes it all happen:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="kt">void</span>
<span class="nf">TileFloodFill</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">UndoStack</span><span class="p">,</span> <span class="n">world</span> <span class="o">*</span><span class="n">World</span><span class="p">,</span> <span class="n">world_position</span> <span class="n">StartP</span><span class="p">,</span> <span class="n">ssa_tile</span> <span class="n">NewTile</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ZLayer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sswm_ground_tile</span> <span class="o">*</span><span class="n">TargetGroundTiles</span> <span class="o">=</span> <span class="n">GetWorldMapGroundTile</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">StartP</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">TargetGroundTiles</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">u32</span> <span class="n">TargetChecksum</span> <span class="o">=</span> <span class="n">TargetGroundTiles</span><span class="o">-&gt;</span><span class="n">CheckSum</span><span class="p">[</span><span class="n">ZLayer</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">TargetChecksum</span> <span class="o">!=</span> <span class="n">NewTile</span><span class="p">.</span><span class="n">CheckSum</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">editor_action</span> <span class="n">FloodFillAction</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">Action_FloodFill</span><span class="p">;</span>
            <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">TileCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">PrevTiles</span> <span class="o">=</span> <span class="p">(</span><span class="n">sswm_ground_tile</span> <span class="o">*</span><span class="p">)</span><span class="n">Platform</span><span class="p">.</span><span class="n">AllocateMemory</span><span class="p">(</span><span class="n">MAX_FILL_TILES</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">sswm_ground_tile</span><span class="p">));</span>

            <span class="n">tile_queue</span> <span class="n">Queue</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="n">Queue</span><span class="p">.</span><span class="n">Front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">Queue</span><span class="p">.</span><span class="n">Rear</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">StartP</span><span class="p">);</span>

            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">world_position</span> <span class="n">P</span> <span class="o">=</span> <span class="n">DeQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">);</span>

                <span class="n">sswm_ground_tile</span> <span class="o">*</span><span class="n">GroundTile</span> <span class="o">=</span> <span class="n">GetWorldMapGroundTile</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">GroundTile</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">GroundTile</span><span class="o">-&gt;</span><span class="n">CheckSum</span><span class="p">[</span><span class="n">ZLayer</span><span class="p">]</span> <span class="o">==</span> <span class="n">TargetChecksum</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">Copy</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sswm_ground_tile</span><span class="p">),</span> <span class="n">GroundTile</span><span class="p">,</span> <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">PrevTiles</span> <span class="o">+</span> <span class="n">FloodFillAction</span><span class="p">.</span><span class="n">FloodFill</span><span class="p">.</span><span class="n">TileCount</span><span class="o">++</span><span class="p">);</span>

                        <span class="n">AddGroundTile</span><span class="p">(</span><span class="n">UndoStack</span><span class="p">,</span> <span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">NewTile</span><span class="p">,</span> <span class="n">ZLayer</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
                        
                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">));</span>
                        <span class="p">}</span>

                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span><span class="p">));</span>
                        <span class="p">}</span>

                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
                        <span class="p">}</span>

                        <span class="k">if</span><span class="p">(</span><span class="n">TileIsValid</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="p">{</span>
                            <span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Queue</span><span class="p">,</span> <span class="n">CenteredTilePoint</span><span class="p">(</span><span class="n">World</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileX</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">TileY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">PushOnActionStack</span><span class="p">(</span><span class="n">UndoStack</span><span class="p">,</span> <span class="n">FloodFillAction</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This function not only simplifies the tile placement process but also supports undo actions, allowing for greater flexibility and creativity while building your world.</p> <h2 id="implementing-undo-and-redo-functionality">Implementing Undo and Redo Functionality</h2> <p>After spending some time working with these new tools, I realized how crucial it was to have the ability to undo and redo actions. To address this, I introduced an <code class="language-plaintext highlighter-rouge">action_stack</code> system that can store and manage actions, allowing you to revert or reapply them as needed. Here’s a look at how this system works:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_UNDO_ACTIONS 128
</span><span class="k">struct</span> <span class="nc">action_stack</span>
<span class="p">{</span>
    <span class="n">editor_action</span> <span class="o">*</span><span class="n">Actions</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">Start</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">End</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">Size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>This <code class="language-plaintext highlighter-rouge">action_stack</code> structure holds an array of <code class="language-plaintext highlighter-rouge">editor_action</code> objects, as well as pointers to the start and end of the stack, and a size indicator. It can store up to 128 actions for undoing and redoing.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">editor_action</span>
<span class="p">{</span>
    <span class="n">action_type</span> <span class="n">Type</span><span class="p">;</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">sswm_ground_tile</span> <span class="n">PrevTile</span><span class="p">;</span>
        <span class="n">flood_fill_action</span> <span class="n">FloodFill</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">editor_action</code> structure includes the type of action and a union to hold the relevant data for undoing or redoing the action. This allows for flexibility in handling different types of actions, whether it’s a simple tile change or a complex flood fill.</p> <p>Here are a few utility functions that manage the stack:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">InitActionStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">,</span> <span class="n">memory_arena</span> <span class="o">*</span><span class="n">Arena</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span> <span class="o">=</span> <span class="n">PushArray</span><span class="p">(</span><span class="n">Arena</span><span class="p">,</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">,</span> <span class="n">editor_action</span><span class="p">);</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">InitActionStack</code> initializes the stack, setting up the memory for storing actions and resetting the start, end, and size indicators.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="n">b32</span>
<span class="nf">IsActionStackEmpty</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b32</span> <span class="n">Result</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">IsActionStackEmpty</code> checks if the stack is empty by evaluating the size.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="kt">void</span>
<span class="nf">PushOnActionStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">,</span> <span class="n">editor_action</span> <span class="n">Action</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span><span class="p">[</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">]</span> <span class="o">=</span> <span class="n">Action</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">&lt;</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">PushOnActionStack</code> adds a new action to the stack. If the stack is full, it overwrites the oldest action.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">internal</span> <span class="n">editor_action</span> <span class="o">*</span>
<span class="nf">PopFromActionStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">editor_action</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">IsActionStackEmpty</span><span class="p">(</span><span class="n">Stack</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="p">(</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_UNDO_ACTIONS</span><span class="p">;</span>
        <span class="o">--</span><span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">;</span>

        <span class="n">Result</span> <span class="o">=</span> <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span> <span class="o">+</span> <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">PopFromActionStack</code> removes the most recent action from the stack, allowing it to be undone.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ClearStack</span><span class="p">(</span><span class="n">action_stack</span> <span class="o">*</span><span class="n">Stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ZeroArray</span><span class="p">(</span><span class="n">MAX_UNDO_ACTIONS</span><span class="p">,</span> <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Actions</span><span class="p">);</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">End</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Stack</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Finally, <code class="language-plaintext highlighter-rouge">ClearStack</code> resets the entire stack, clearing all stored actions.</p> <h2 id="whats-next">What’s Next?</h2> <p>The journey doesn’t end here! I’m already working on implementing navigation meshes and will continue refining the editor to enhance usability and expand its capabilities. My goal is to make building the world of Spellweaver Saga as intuitive and enjoyable as possible. There is a little gallery below, you can check it out.</p> <p>Happy spellweaving, <strong><a href="https://github.com/babykaban">BabyKaban</a></strong></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/editor_picture_0-480.webp 480w,/assets/img/editor_picture_0-800.webp 800w,/assets/img/editor_picture_0-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/editor_picture_0.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/editor_picture_1-480.webp 480w,/assets/img/editor_picture_1-800.webp 800w,/assets/img/editor_picture_1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/editor_picture_1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/editor_picture_2-480.webp 480w,/assets/img/editor_picture_2-800.webp 800w,/assets/img/editor_picture_2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/editor_picture_2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/editor_picture_3-480.webp 480w,/assets/img/editor_picture_3-800.webp 800w,/assets/img/editor_picture_3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/editor_picture_3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/editor_picture_4-480.webp 480w,/assets/img/editor_picture_4-800.webp 800w,/assets/img/editor_picture_4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/editor_picture_4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/editor_picture_5-480.webp 480w,/assets/img/editor_picture_5-800.webp 800w,/assets/img/editor_picture_5-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/editor_picture_5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Editor update]]></summary></entry><entry><title type="html">Introducing Spellweaver Saga World Map (SSWM)</title><link href="https://babykaban.github.io/blog/2024/editor-update-sswm-format/" rel="alternate" type="text/html" title="Introducing Spellweaver Saga World Map (SSWM)"/><published>2024-07-29T00:00:00+00:00</published><updated>2024-07-29T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/editor-update-sswm-format</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/editor-update-sswm-format/"><![CDATA[<p>Hello, Spellweavers!</p> <p>I’m excited to share a significant update in the development of <strong>Spellweaver Saga: Retrieving The Legendary Relic</strong>. As I delve deeper into refining the game’s mechanics and world-building tools, I’ve decided to rebuild the editor’s ‘terrain’ mode and introduce a fresh file format called <strong>Spellweaver Saga World Map (SSWM)</strong>.</p> <h2 id="the-evolution-of-terrain-mode">The Evolution of Terrain Mode</h2> <p>In the previous iteration of the editor, the terrain mode was relatively straightforward. It was essentially a grid where I could place different tiles to create a tile map. While this was functional, it lacked the flexibility needed for the interactions I envisioned in the game.</p> <h2 id="sswm-a-new-file-format">SSWM: A New File Format</h2> <p>The SSWM file format represents a significant leap forward in how the game’s world is structured and managed. Here’s what SSWM brings to the table:</p> <ul> <li><strong>Tile Grid</strong>: This grid holds bitmap IDs for ground tiles along with their positions, almost like the previous version. This change allows tiles to be spawned as entities, opening up a world of interaction possibilities within the game.</li> <li><strong>Entities Metadata</strong>: An array of entities’ metadata will be stored within the SSWM file, facilitating more dynamic and rich world creation.</li> <li><strong>Polygons and Navigation Meshes</strong>: One of the most exciting additions is the potential to store polygons and graphs for navigation meshes. This idea appeared as I was refining the current movement system and realized that it sucked. Navigation meshes will enhance pathfinding and movement, making gameplay smoother and more intuitive.</li> </ul> <h2 id="why-sswm">Why SSWM?</h2> <p>The beauty of SSWM files lies in their versatility. They will be stored in the game asset file format, <strong>Spellweaver Saga Assets (SSA)</strong>, ensuring seamless integration and organization of all game assets.</p> <h2 id="whats-next">What’s Next?</h2> <p>Next, I’ll focus on improving and continuing to develop the editor to create game levels. This involves enhancing the tools to generate polygons and graphs for navigation meshes and refining other aspects to make level creation more efficient.</p> <p>Stay tuned for more updates as I continue to build and refine <strong>Spellweaver Saga: Retrieving The Legendary Relic</strong>. Your support and enthusiasm fuel this adventure!</p> <p>Happy spellweaving, Paul</p>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Editor update]]></summary></entry><entry><title type="html">Welcome to the Spellweaver Saga Blog!</title><link href="https://babykaban.github.io/blog/2024/welcome-to-the-spellweaver-saga-blog/" rel="alternate" type="text/html" title="Welcome to the Spellweaver Saga Blog!"/><published>2024-07-24T00:00:00+00:00</published><updated>2024-07-24T00:00:00+00:00</updated><id>https://babykaban.github.io/blog/2024/welcome-to-the-spellweaver-saga-blog</id><content type="html" xml:base="https://babykaban.github.io/blog/2024/welcome-to-the-spellweaver-saga-blog/"><![CDATA[<p>Hello everyone,</p> <p>Welcome to the very first blog post for Spellweaver Saga: Retrieving The Legendary Relic! I’m Paul, the developer behind this indie game, and I’m excited to share my journey with you as I work on bringing this project to life.</p> <h1 id="game-concept">Game Concept</h1> <p>The main concept of Spellweaver Saga revolves around the player’s ability to manipulate magic elements and combine them into spells or perform actions. This mechanic is central to the entire gameplay experience. The story follows a young mage who embarks on a quest to find a powerful artifact to protect his village. This artifact was researched by his mentor, who mysteriously disappeared.</p> <h1 id="development-journey">Development Journey</h1> <p>This game is being developed on a custom engine written in C/C++. I chose to develop my own engine to deepen my understanding of programming. Although the engine is still a work in progress, I decided to proceed with creating a game to test its capabilities. After completing a prototype and evaluating the engine’s abilities, I began designing and developing the game. There were many challenges along the way, especially since I was new to game and engine development.</p> <h1 id="challenges-and-solutions">Challenges and Solutions</h1> <p>One of the most significant challenges was the overall development process. I was able to overcome many hurdles thanks to the guidance provided by the video series Handmade Hero by Casey Muratori and other internet sources. These resources have been invaluable in helping me understand game development on a deeper level.</p> <h1 id="prototype-features">Prototype Features</h1> <p>The current prototype includes a basic map layout, a few quests, and the core mechanic of combining elements. This mechanic will be significantly improved in the next version of the game. Over the last few months, I have also been working on the game’s editor, which is a crucial part of the development process. The editor currently has the capability to create custom asset files for the game.</p> <h1 id="next-steps">Next Steps</h1> <p>The next steps in the development process include finishing the editor and starting on the first levels and designs of the game. I am excited to continue this journey and share updates with you as the game progresses.</p> <h1 id="community-and-feedback">Community and Feedback</h1> <p>You can find the game prototype on the <a href="/projects/spellweaver_saga/">projects page</a> or watch a demo <a href="https://www.youtube.com/watch?v=7211-m05OSI">here</a>. I would love to hear your feedback and thoughts as I continue to develop Spellweaver Saga. Your input will be invaluable in shaping the final game.</p> <p>Thank you for joining me on this journey. Stay tuned for more updates and insights into the development process of Spellweaver Saga: Retrieving The Legendary Relic.</p> <p>Best, Paul</p>]]></content><author><name></name></author><category term="blog"/><summary type="html"><![CDATA[Very First Blog Post]]></summary></entry></feed>